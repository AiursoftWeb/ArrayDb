# ArrayDb 查询语言设计

本文档对 Aql（Array Query Language）的设计进行了详细描述，旨在建立一种形式严谨、易于静态类型检查且表达直观的查询语言。本文涵盖了数据类型、表达式语法、内建运算符（包括重载与隐式转换规则）、运算符优先级以及查询管道语法。

---

## 1. 数据类型

Aql 内置的数据类型固定为以下基本类型，每个查询结果均为一张表，每列的类型必须为以下某一种：

- **int**：32 位有符号整数  
- **long**：64 位有符号整数  
- **float**：单精度浮点数  
- **double**：双精度浮点数  
- **bool**：布尔型，仅有值 `true` 与 `false`  
- **string**：字符串  
- **dateTime**：日期时间类型  
- **timeSpan**：时间间隔  
- **guid**：全局唯一标识符  
- **byteArray**：字节数组

---

## 2. 表达式与字面量

Aql 中的表达式出现在管道中间件（如 `where`、`sort` 等）或用于算术计算中。基本构成要素包括：

- **字面量**：直接写出的常量（数字、字符串、布尔值、日期字面量等）。
- **标识符**：用于引用当前行的列值，如 `Assets`、`Age`、`Country`。

求值时，字面量直接解析为常量值，而标识符在当前行的上下文中解析为对应列的值。所有表达式均带有类型，编译器在类型检查阶段保证表达式满足所在上下文的类型要求，同时支持适当的隐式转换（见下文）。

---

## 3. 运算符及其语义

Aql 中的运算符定义明确，部分运算符根据操作数类型进行重载，同时支持一定范围内的隐式类型转换。下面分别说明各类运算符的要求、返回类型及特殊语义。

### 3.1 比较与逻辑运算

- **==, !=**  
  - **要求**：左右操作数类型必须严格相同，或处于允许的隐式转换范围内（例如 int 可隐式转换为 long、float 或 double）。  
  - **返回类型**：`bool`  
  - **语义**：判断两个值是否相等或不等。

- **>, <, >=, <=**  
  - **要求**：左右操作数均为**数字型**（包括 int、long、float、double）或 **dateTime/timeSpan**（用于比较先后或时间间隔长短）。  
  - **返回类型**：`bool`  
  - **注意**：对非数字类型（例如 string）不支持大小比较，除非另行定义转换规则。

- **&&, ||, !**  
  - **要求**：操作数均为 `bool` 类型。  
  - **返回类型**：`bool`  
  - **语义**：分别表示逻辑与、逻辑或和逻辑非。

### 3.2 字符串相关运算

- **contains, startswith, endswith**  
  - **要求**：左侧必须为 `string`，右侧为 `string`。  
  - **返回类型**：`bool`  
  - **语义**：判断左侧字符串是否分别包含、以……开始或以……结束右侧字符串。

- **in**  
  - **要求**：左侧为 `string`；右侧为列表字面量，用大括号构造，如 `{ "USA", "China", "Japan" }`。  
  - **返回类型**：`bool`  
  - **语义**：判断左侧字符串是否存在于右侧字符串集合中。  
  - **说明**：右侧可以由列引用、内置常量或专用的数组字面量构造（区分于 `byteArray` 的字面量）。

- **isEmpty**  
  - **要求**：操作数为 `string`。  
  - **返回类型**：`bool`  
  - **语义**：判断字符串是否为空（或空串）。

### 3.3 算术运算与加法重载

- **+**  
  根据操作数类型不同，`+` 运算符具有如下重载语义：  
  - **数字加法**：若左右均为数字类型（int、long、float、double），执行数值加法；  
  - **字符串连接**：若左右均为 `string`，或一边为 `string`且另一边为数字（此时数字隐式转换为字符串），执行字符串连接；  
  - **日期运算**：允许 `dateTime + timeSpan` 得到新的 `dateTime`；  
  - **时间间隔加法**：`timeSpan + timeSpan` 返回新的 `timeSpan`。

- **-**  
  - **数字减法**：要求左右均为数字类型；  
  - **日期运算**：允许 `dateTime - timeSpan` 得到新的 `dateTime`；  
  - **时间间隔减法**：`timeSpan - timeSpan` 返回 `timeSpan`。

- **\***、**/**、**%**  
  - **要求**：左右均为数字。  
  - **返回类型**：数字  
  - **语义**：分别为乘法、除法和模运算（模运算仅适用于整数）。

### 3.4 位运算（仅适用于 int 类型）

- **& (按位与)**、**| (按位或)**、**^ (按位异或)**  
  - **要求**：左右均为 `int`。  
  - **返回类型**：`int`。

- **~ (按位取反)**  
  - **要求**：操作数为 `int`。  
  - **返回类型**：`int`。

- **<< (左移)**、**>> (右移)**  
  - **要求**：左右均为 `int`。  
  - **返回类型**：`int`。

### 3.5 数组索引

- **[]**  
  - **用法**：`expr[index]`  
  - **要求**：`expr` 必须为 `byteArray` 类型；索引 `index` 必须为 `int`。  
  - **返回类型**：`int`，表示字节数组中指定索引位置的字节值。  
  - **注意**：索引从 0 开始，且仅对 `byteArray` 类型适用。

### 3.6 三元运算符

- **?:**  
  - **形式**：`cond ? expr1 : expr2`  
  - **要求**：条件 `cond` 必须为 `bool`；`expr1` 与 `expr2` 的类型必须一致，或能通过隐式转换达到一致。  
  - **返回类型**：与 `expr1`（和 `expr2`）相同。  
  - **语义**：当 `cond` 为 true 时返回 `expr1`，否则返回 `expr2`。

### 3.7 运算符重载与隐式类型转换规则

为保证表达式求值既严格又灵活，Aql 定义了以下隐式转换规则和运算符重载策略：

1. **数值类型转换**  
   - 转换顺序：`int` → `long` → `float` → `double`。  
   - 在混合运算中（例如 int 与 double 参与加减乘除），较低精度类型自动提升为较高精度类型，以确保计算精度。

2. **字符串与数值间的转换**  
   - 对于加法运算，若任一操作数为 `string`，则另一操作数（若为数值类型）将被隐式转换为字符串，执行字符串连接。

3. **日期与时间间隔运算**  
   - `dateTime` 与 `timeSpan` 之间的加法或减法直接按日期运算进行；  
   - 同类型的 `timeSpan` 之间的加减运算返回 `timeSpan`。

4. **比较运算的隐式转换**  
   - 当左右操作数不完全相同但存在隐式转换关系时（如 int 与 long、float 与 double），在比较前会进行适当转换。  
   - 对于非数值类型，除非明确定义转换（例如 string 与日期等不自动转换），否则不允许隐式转换。

5. **运算符重载的静态类型检查**  
   - 编译器在类型检查阶段将依据上述转换规则判断操作数是否满足运算符要求，若不能通过隐式转换达到要求，则产生编译错误。  
   - 此机制确保字面量与列值混用时，依然能够进行安全求值。

---

## 4. 运算符优先级

为消除解析歧义，Aql 明确定义各运算符的优先级（从最高到最低）如下：

1. **括号**： `()`  
2. **一元运算符**： `!`、`~`、以及一元负号 `-`（取负）  
3. **乘法运算**： `*`、`/`、`%`  
4. **加法运算**： `+`、`-`  
5. **位移运算**： `<<`、`>>`  
6. **关系运算**： `<`、`<=`、`>`、`>=`  
7. **相等运算**： `==`、`!=`  
8. **字符串相关运算**： `contains`、`startswith`、`endswith`、`in`  
   > 注：可视具体情况与相等运算同级，或稍低于关系运算，消除歧义时建议使用括号。
9. **位运算**：  
   - 按位与： `&`  
   - 按位异或： `^`  
   - 按位或： `|`  
10. **逻辑运算**：  
    - 逻辑与： `&&`  
    - 逻辑或： `||`  
11. **三元运算符**： `?:`（最低优先级）

---

## 5. 表达式的形式化语法

下面给出简化版的 EBNF 描述，涵盖字面量、标识符及所有运算符（其中字符串运算符与相等运算同层级）：

```
<Expression>      ::= <TernaryExpr>

<TernaryExpr>     ::= <LogicalOrExpr>
                    | <LogicalOrExpr> "?" <Expression> ":" <Expression>

<LogicalOrExpr>   ::= <LogicalAndExpr> { "||" <LogicalAndExpr> }

<LogicalAndExpr>  ::= <BitwiseOrExpr> { "&&" <BitwiseOrExpr> }

<BitwiseOrExpr>   ::= <BitwiseXorExpr> { "|" <BitwiseXorExpr> }

<BitwiseXorExpr>  ::= <BitwiseAndExpr> { "^" <BitwiseAndExpr> }

<BitwiseAndExpr>  ::= <EqualityExpr> { "&" <EqualityExpr> }

<EqualityExpr>    ::= <RelationalExpr> { ( "==" | "!=" 
                                          | "contains" | "startswith" | "endswith"
                                          | "in" ) ( <RelationalExpr> | <ListLiteral> ) }

<RelationalExpr>  ::= <ShiftExpr> { ( "<" | "<=" | ">" | ">=" ) <ShiftExpr> }

<ShiftExpr>       ::= <AdditiveExpr> { ( "<<" | ">>" ) <AdditiveExpr> }

<AdditiveExpr>    ::= <MultiplicativeExpr> { ( "+" | "-" ) <MultiplicativeExpr> }

<MultiplicativeExpr> ::= <UnaryExpr> { ( "*" | "/" | "%" ) <UnaryExpr> }

<UnaryExpr>       ::= [ ( "!" | "~" | "-" ) ] <PostfixExpr>

<PostfixExpr>     ::= <PrimaryExpr> { "[" <Expression> "]" }

<PrimaryExpr>     ::= <Literal>
                    | <Identifier>
                    | "(" <Expression> ")"

<ListLiteral>     ::= "{" <Literal> { "," <Literal> } "}"
```

**说明：**  
- `<Literal>` 表示各类字面量（数字、字符串、bool、dateTime 等）；  
- `<Identifier>` 表示对表中列的引用；  
- 数组索引（`[ ]`）仅适用于 `byteArray` 类型；  
- 三元运算符 `?:` 为右结合。

---

## 6. 查询与管道语法

Aql 的顶层查询语句整体上为一个 **管道表达式**，结构如下：

```
<TableName>
  { "|" <Middleware> }
```

- **起始部分**：必须以一个标识符开始，引用数据库中的表。
- **管道操作符**：每个中间件以 `|` 开始，后跟中间件名称及其参数（参数本身为 Aql 表达式或表达式组）。

### 6.1 常见中间件示例

- **take**  
  ```aql
  MyTable
  | take 10
  ```  
  意义：截取前 10 行，参数要求为整型表达式。

- **skip**  
  ```aql
  MyTable
  | skip 10
  | take 20
  ```  
  意义：跳过前 10 行，再取接下来的 20 行。

- **where**  
  ```aql
  MyTable
  | where (Assets > 1000000000 && Country == "USA") ||
          (Age == 18 && Gender == "Female" && Occupation != "Programmer")
  ```  
  意义：筛选出满足给定布尔表达式的行。表达式中标识符引用当前行的列值。

- **sample**  
  ```aql
  Customers
  | sample 1 from 10
  ```  
  意义：从结果中每隔 10 行抽取一行，参数为具体数字。

- **sort**  
  ```aql
  Customers
  | sort by Age desc
  ```  
  意义：根据指定字段（如 `Age`）排序，支持数字、日期等可比较类型。

### 6.2 Summarize（Group By）中间件

为支持分组聚合操作，Aql 新增了 **summarize** 关键字，其语法类似于 SQL 中的 GROUP BY 与聚合函数组合。

#### 6.2.1 语法格式

```
<TableName>
  { "|" <Middleware> }
  | summarize <AggregateList> [ "by" <GroupingList> ]
```

其中：

- **<AggregateList>**  
  为一组聚合函数调用，可用逗号分隔，每个调用可选地使用 `as` 指定别名。支持的聚合函数包括但不限于：  
  - `count()`  
  - `sum(<Expression>)`  
  - `avg(<Expression>)`  
  - `min(<Expression>)`  
  - `max(<Expression>)`

- **<GroupingList>**  
  为一个或多个标识符或表达式，用以指定分组键，多个分组键之间用逗号分隔。

#### 6.2.2 示例

- **无分组聚合**  
  对整个表进行聚合：
  ```aql
  MyTable
  | summarize count() as TotalRows, sum(Assets) as TotalAssets
  ```
  返回一张只有一行的表，包含总行数及总资产和。

- **基于分组键聚合**  
  按国家分组，统计每个国家的用户数和资产总和：
  ```aql
  Customers
  | summarize count() as UserCount, sum(Assets) as AssetsSum by Country
  ```
  返回一张表，每行对应一个国家及其统计结果。

#### 6.2.3 语义说明

- **分组操作**：在 `by` 后的表达式（或标识符）确定分组键。所有在聚合函数中引用的表达式均在各自分组内求值。  
- **聚合函数要求**：各聚合函数参数类型应满足函数要求（例如 `sum` 仅适用于数值型），聚合函数结果的类型决定返回表对应列的类型。  
- **混合表达式**：分组键和聚合表达式可以混用字面量与标识符，但编译器会根据上下文和隐式转换规则进行类型检查。

---

## 7. 字面量与引用

在 Aql 中，表达式中操作数既可以是字面量（例如 `3`、`"USA"`），也可以是标识符引用（例如 `Age`、`Country`）。二者在语法上无差别，但在求值时具有不同语义：

- **字面量**：直接解析为固定常量。  
- **标识符**：在执行时根据当前行的上下文解析为列值。

编译器在类型检查阶段会保证两者的类型一致性，或通过隐式转换规则将不匹配的类型统一后再进行求值。

---

## 8. 小结

本文档详细描述了 Aql 语言的设计，包括：

- **数据类型**：固定的基本类型集合。  
- **表达式构成**：字面量与标识符构成的严格带类型的表达式。  
- **运算符语义**：涵盖比较、逻辑、字符串、算术、位运算、数组索引、三元运算，并引入了运算符重载与隐式类型转换规则，确保混合类型表达式能够在安全前提下求值。  
- **运算符优先级与语法形式**：通过 EBNF 形式化描述，明确各运算符的结合性与优先级，避免歧义。  
- **查询管道语法**：支持常用中间件（take、skip、where、sample、sort）及新增的 summarize 聚合操作，实现类似 group by 的功能。

这种设计既保证了 Aql 在语法与语义上的严谨性，又兼顾直观易用，为 ArrayDb 打下坚实基础。后续工作将进一步细化隐式转换细节、错误处理机制以及更多聚合与窗口函数的支持。
